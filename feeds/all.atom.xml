<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Sayantan Khan's Blog</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2018-04-20T00:00:00+05:30</updated><entry><title>Construction of Chern classes</title><link href="/chern-classes.html" rel="alternate"></link><published>2018-04-20T00:00:00+05:30</published><updated>2018-04-20T00:00:00+05:30</updated><author><name>Sayantan Khan</name></author><id>tag:None,2018-04-20:/chern-classes.html</id><summary type="html">&lt;h2&gt;Characteristic classes&lt;/h2&gt;
&lt;p&gt;Given a manifold &lt;span class="math"&gt;\(M\)&lt;/span&gt;, one way to study vector bundles over &lt;span class="math"&gt;\(M\)&lt;/span&gt; is to use the theory of
characteristic classes. A characteristic class is a way of assigning to each vector bundle over &lt;span class="math"&gt;\(M\)&lt;/span&gt;
an element of the cohomology ring &lt;span class="math"&gt;\(H^{\ast}(M, G)\)&lt;/span&gt;. This assignment is not …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Characteristic classes&lt;/h2&gt;
&lt;p&gt;Given a manifold &lt;span class="math"&gt;\(M\)&lt;/span&gt;, one way to study vector bundles over &lt;span class="math"&gt;\(M\)&lt;/span&gt; is to use the theory of
characteristic classes. A characteristic class is a way of assigning to each vector bundle over &lt;span class="math"&gt;\(M\)&lt;/span&gt;
an element of the cohomology ring &lt;span class="math"&gt;\(H^{\ast}(M, G)\)&lt;/span&gt;. This assignment is not just any arbitrary
assignment; it has to satisfy a &lt;em&gt;naturality&lt;/em&gt; condition. If &lt;span class="math"&gt;\((F, N, \pi_2)\)&lt;/span&gt; is a vector
bundle, &lt;span class="math"&gt;\(f: M \to N\)&lt;/span&gt; is a smooth map, (E, M, \pi_1) is the &lt;a href="https://en.wikipedia.org/wiki/Pullback_bundle"&gt;pullback bundle&lt;/a&gt;,
and &lt;span class="math"&gt;\(c(E)\)&lt;/span&gt; and &lt;span class="math"&gt;\(c(F)\)&lt;/span&gt; are the cohomology classes assigned to &lt;span class="math"&gt;\(E\)&lt;/span&gt; and &lt;span class="math"&gt;\(F\)&lt;/span&gt; by the characteristic class
&lt;span class="math"&gt;\(c\)&lt;/span&gt;, then the pullback of &lt;span class="math"&gt;\(c(F)\)&lt;/span&gt; along the map &lt;span class="math"&gt;\(f\)&lt;/span&gt; is &lt;span class="math"&gt;\(c(E)\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
c(E) = f^{\ast}(c(F))
\end{align*}&lt;/div&gt;
&lt;p&gt;
The naturality condition is what makes characteristic classes so useful: it tells us that
characteristic classes are an invariant of vector bundles over a manifold. If two vector
bundles are isomorphic, they'll get assigned the same characteristic class.&lt;/p&gt;
&lt;p&gt;The first step in studying characteristic classes is to construct interesting examples of them.
Its definition is certainly not of much help in actually constructing any examples. In fact,
constructing characteristic classes is not entirely trivial, and requires some work. We'll look
at one way of constructing characteristic classes, called Chern classes. This construction
is quite non-trivial, and requires the use of differential geometric machinery. The advantage of this
construction however, is that it gives an explicit way of constructing characteristic classes over
a lot of familiar vector bundles.&lt;/p&gt;
&lt;h2&gt;Connections on vector bundles&lt;/h2&gt;
&lt;p&gt;Given a rank &lt;span class="math"&gt;\(k\)&lt;/span&gt; vector bundle &lt;span class="math"&gt;\((E, M)\)&lt;/span&gt;, a connection on the vector bundle is a bundle map &lt;span class="math"&gt;\(\nabla\)&lt;/span&gt; from
&lt;span class="math"&gt;\(E\)&lt;/span&gt; to &lt;span class="math"&gt;\(E \otimes T^{\ast}M\)&lt;/span&gt; which satisfies the following condition for all smooth real-valued functions &lt;span class="math"&gt;\(f\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\nabla(fv) = v \otimes df + f (\nabla v)
\end{align*}&lt;/div&gt;
&lt;p&gt;
If we pick local coordinates and a trivialization around some point in &lt;span class="math"&gt;\(M\)&lt;/span&gt;, then the connection
&lt;span class="math"&gt;\(\nabla\)&lt;/span&gt; can be described by a &lt;span class="math"&gt;\(k \times k\)&lt;/span&gt; matrix of &lt;span class="math"&gt;\(1\)&lt;/span&gt;-forms, which we'll denote
&lt;span class="math"&gt;\(A\)&lt;/span&gt;, where the &lt;span class="math"&gt;\(i\)&lt;/span&gt;&lt;sup&gt;th&lt;/sup&gt; column
denotes what &lt;span class="math"&gt;\(\nabla e_i\)&lt;/span&gt; goes to, where &lt;span class="math"&gt;\(\{e_i\}\)&lt;/span&gt; is the local frame for the vector bundle.
The matrix &lt;span class="math"&gt;\(A\)&lt;/span&gt; is often called a &lt;a href="https://en.wikipedia.org/wiki/Connection_form"&gt;connection form&lt;/a&gt;.
Using the matrix &lt;span class="math"&gt;\(A\)&lt;/span&gt;, we can construct another matrix, this one consisting of &lt;span class="math"&gt;\(2\)&lt;/span&gt;-forms, which we'll call
the curvature form&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\Omega = dA + A \wedge A
\end{align*}&lt;/div&gt;
&lt;p&gt;
The curvature form will be the key tool we'll use to construct the Chern classes.&lt;/p&gt;
&lt;h2&gt;Constructing globally defined forms using curvature&lt;/h2&gt;
&lt;p&gt;The nice thing about the curvature form is that it transforms in a particularly
nice manner when one changes the trivialization for the vector bundle. If &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt;
is the curvature matrix in the old trivialization, and the new trivialization is given
by multiplying by an invertible matrix &lt;span class="math"&gt;\(g\)&lt;/span&gt;, then in the new trivialization, the curvature
matrix is given by &lt;span class="math"&gt;\(g\Omega g^{-1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Consider the trace of the curvature matrix defined on some open set. The trace will be
a locally defined &lt;span class="math"&gt;\(2\)&lt;/span&gt;-form. Now recall that for any matrix &lt;span class="math"&gt;\(M\)&lt;/span&gt;, &lt;span class="math"&gt;\(\mathrm{tr}(M) = \mathrm{tr}(gMg^{-1})\)&lt;/span&gt;.
This means that we can defined a "trace" of the curvature form globally (using a partition of unity argument),
and this gives us a globally defined &lt;span class="math"&gt;\(2\)&lt;/span&gt;-form. In fact, this can be done for any homogeneous
polynomial in the entries of a matrix
which is conjugation invariant, e.g. the determinant. Doing this for the determinant will give
us a globally defined &lt;span class="math"&gt;\(2k\)&lt;/span&gt;-form. We now have a way of constructing globally defined forms
using the curvature form.&lt;/p&gt;
&lt;p&gt;Let's take a pause here to recall our goal. We want to associate to each vector bundle over &lt;span class="math"&gt;\(M\)&lt;/span&gt;
an element of &lt;span class="math"&gt;\(H^{\ast}(M)\)&lt;/span&gt;. What we have done so far is to associate to each vector bundle &lt;span class="math"&gt;\(E\)&lt;/span&gt;
and a choice of connection &lt;span class="math"&gt;\(\nabla\)&lt;/span&gt; on that bundle a collection of differential forms. If we manage to show
that the differential form is actually closed, we'll have an assignment of &lt;span class="math"&gt;\((E, \nabla)\)&lt;/span&gt; to an element
of &lt;span class="math"&gt;\(H^{\ast}_{DR}(M)\)&lt;/span&gt;. Furthermore, if we show that the assignment to the cohomology class
is independent of which connection we pick, we'll have constructed a characteristic class. In the following
sections, we'll do both of the mentioned things, i.e. show that the globally defined forms are closed,
and their cohomology class is independent of the connection chosen.&lt;/p&gt;
&lt;h3&gt;The globally defined forms are closed&lt;/h3&gt;
&lt;p&gt;To show that the globally defined forms are closed, we'll need a systematic way of taking
their exterior derivative. The first step in that direction would be to simplify the expression
for the connection form &lt;span class="math"&gt;\(A\)&lt;/span&gt; by picking a nice trivialization. In fact, we can pick a trivialization
in which the connection matrix &lt;span class="math"&gt;\(A\)&lt;/span&gt; is &lt;span class="math"&gt;\(0\)&lt;/span&gt; at a point. The proof of this fact is outlined in these
&lt;a href="http://www.math.iisc.ac.in/~vamsipingali/6Feb2018.pdf"&gt;notes&lt;/a&gt; (and some formulae used are derived in these
&lt;a href="http://www.math.iisc.ac.in/~vamsipingali/1Feb2018.pdf"&gt;notes&lt;/a&gt;). We'll call this trivialization a &lt;em&gt;normal trivialization&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This result already tells us that the &lt;span class="math"&gt;\(2\)&lt;/span&gt;-form defined by taking the trace of the curvature is
closed. Pick a normal trivialization around &lt;span class="math"&gt;\(p\)&lt;/span&gt;; this makes &lt;span class="math"&gt;\(A\)&lt;/span&gt; vanish at &lt;span class="math"&gt;\(p\)&lt;/span&gt;. Then at that point, the curvature
matrix is just &lt;span class="math"&gt;\(dA\)&lt;/span&gt;. The exterior derivative of the trace of this is the same as the trace of &lt;span class="math"&gt;\(d^2A\)&lt;/span&gt;
(because the trace is a homogeneous degree &lt;span class="math"&gt;\(1\)&lt;/span&gt; polynomial in the entries of the matrix),
which is &lt;span class="math"&gt;\(0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To extend this idea to homogeneous polynomials of higher degrees, we need some way "linearizing" them,
so that we can take their exterior derivative easily. We do this by &lt;em&gt;polarizing&lt;/em&gt; them. The polarization
of a degree &lt;span class="math"&gt;\(j\)&lt;/span&gt; homogeneous polynomial &lt;span class="math"&gt;\(f\)&lt;/span&gt; in the entries of the matrix is a function &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; that takes &lt;span class="math"&gt;\(j\)&lt;/span&gt;
matrix arguments, and outputs an element of the algebra over which the matrices are defined. The function &lt;span class="math"&gt;\(\phi\)&lt;/span&gt;
is linear in each of its arguments, is symmetric in the order of its arguments, and is conjugation invariant, i.e.
it satisfies the following identity for all invertible matrices &lt;span class="math"&gt;\(g\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\phi(A_1, \ldots , A_j) = \phi(gA_1g^{-1}, \ldots , gA_jg^{-1})
\end{align*}&lt;/div&gt;
&lt;p&gt;
Furthermore, &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; must also satisfy the following polarization identity for all matrices &lt;span class="math"&gt;\(A\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\phi(A, \ldots , A) = f(A)
\end{align*}&lt;/div&gt;
&lt;p&gt;
This last equality is why &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; is called the polarization of &lt;span class="math"&gt;\(f\)&lt;/span&gt;.
Constructing the polarization of a homogeneous degree &lt;span class="math"&gt;\(j\)&lt;/span&gt; polynomial isn't too hard.
The first step is to just construct a multilinear function that satisfies the polarization
identity. One does that by taking each monomial in the expression for &lt;span class="math"&gt;\(f\)&lt;/span&gt;, and replacing
the &lt;span class="math"&gt;\(i\)&lt;/span&gt;&lt;sup&gt;th&lt;/sup&gt; factor by the corresponding factor in the &lt;span class="math"&gt;\(i\)&lt;/span&gt;&lt;sup&gt;th&lt;/sup&gt; argument.&lt;/p&gt;
&lt;p&gt;This is best illustrated by a simple example. Suppose we are working with &lt;span class="math"&gt;\(2 \times 2\)&lt;/span&gt; matrices,
and the polynomial we want to polarize is the determinant polynomial. Its expression is given
in the following manner.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
f(\{a_{ij}\}) = a_{11}a_{22} - a_{12}a_{21}
\end{align*}&lt;/div&gt;
&lt;p&gt;
Its polarization &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; must have two arguments. We'll denote the entries of the first
argument by superscript &lt;span class="math"&gt;\(1\)&lt;/span&gt; and the second by superscript &lt;span class="math"&gt;\(2\)&lt;/span&gt;. Then the first step would
be two write the following expression.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
a^1_{11}a^2_{22} - a^1_{12}a^2_{21}
\end{align*}&lt;/div&gt;
&lt;p&gt;Whatever we get in the previous step certainly is multilinear in the arguments and satisfies the
polarization identity. The next step is to symmetrize it. That can be easily done by taking
all permutations of the arguments and taking an average over them. This continues to satisfy
the polarization identity and is multilinear and symmetric. The only thing to do now is to make
&lt;span class="math"&gt;\(\phi\)&lt;/span&gt; conjugation invariant. But as it turns out, &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; is already conjugation invariant,
because &lt;span class="math"&gt;\(f\)&lt;/span&gt; is conjugation invariant. The proof of this fact is a little tricky,
and is outlined in the next few paragraphs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;span class="math"&gt;\(f\)&lt;/span&gt; is a conjugation invariant degree &lt;span class="math"&gt;\(j\)&lt;/span&gt; polynomial in the entries 
of a matrix, and &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; is its symmetric and multilinear polarization, then &lt;span class="math"&gt;\(\phi\)&lt;/span&gt;
is also conjugation invariant (which we'll also call basis invariant).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;     We'll prove this lemma by inducting on the number of distinct matrices in the arguments of
    &lt;span class="math"&gt;\(\phi\)&lt;/span&gt;. Observe that &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; can have at most &lt;span class="math"&gt;\(j\)&lt;/span&gt; distinct matrices as arguments. What we'll show
    is that the following equality holds, when &lt;span class="math"&gt;\(\left\{ A_1, A_2, \ldots, A_j\right\}\)&lt;/span&gt; contain at
    most &lt;span class="math"&gt;\(m\)&lt;/span&gt; distinct matrices for each &lt;span class="math"&gt;\(1 \leq m \leq j\)&lt;/span&gt;.
    &lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
      \phi\left(gA_1g^{-1}, gA_2g^{-1}, \ldots, gA_jg^{-1}\right)  = \phi\left(A_1, A_2, \ldots, A_j\right)
    \end{align*}&lt;/div&gt;
&lt;p&gt;
    Let's start with the base case of &lt;span class="math"&gt;\(m=1\)&lt;/span&gt;. This follows from the hypothesis that &lt;span class="math"&gt;\(f\)&lt;/span&gt; is basis
    invariant, since &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; with all identical arguments is just the function &lt;span class="math"&gt;\(f\)&lt;/span&gt;. Now suppose we
    have shown the result for some &lt;span class="math"&gt;\(m &amp;lt; j\)&lt;/span&gt;. We now need to show &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; is basis invariant when
    supplied with at most &lt;span class="math"&gt;\(m+1\)&lt;/span&gt; different arguments. Pick any set of &lt;span class="math"&gt;\(m+1\)&lt;/span&gt; matrices
    &lt;span class="math"&gt;\(\left\{A_1, A_2, \ldots, A_{m+1}\right\}\)&lt;/span&gt;, and any invertible matrix &lt;span class="math"&gt;\(g\)&lt;/span&gt;. We want to show the
    following equality (with some of arguments repeated possibly, if &lt;span class="math"&gt;\(m+1 &amp;lt; j\)&lt;/span&gt;).
    &lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
      \phi\left(gA_1g^{-1}, gA_2g^{-1}, \ldots, gA_{m+1}g^{-1}\right)  = \phi\left(A_1, A_2, \ldots, A_{m+1}\right)
    \end{align*}&lt;/div&gt;
&lt;p&gt;
    Consider the following expression, for &lt;span class="math"&gt;\(t \in \mathbb{C}\)&lt;/span&gt;.
    &lt;/p&gt;
&lt;div class="math"&gt;\begin{align}
      \phi\left( A_1 + tA_{m+1}, A_1 + tA_{m+1}, \ldots, A_1 + tA_{m+1}, A_2, \ldots, A_m \right) \label{eq:1}
    \end{align}&lt;/div&gt;
&lt;p&gt;
    Here, &lt;span class="math"&gt;\(A_1 + tA_{m+1}\)&lt;/span&gt; is repeated &lt;span class="math"&gt;\(j -m\)&lt;/span&gt; times. Since expression &lt;span class="math"&gt;\(\ref{eq:1}\)&lt;/span&gt; has at most &lt;span class="math"&gt;\(m\)&lt;/span&gt;
    distinct arguments, we can use the induction hypothesis to conclude that expression \ref{eq:1}
    would be the same if we conjugated all arguments with &lt;span class="math"&gt;\(g\)&lt;/span&gt;. In fact, expression \ref{eq:1} can be
    expanded out to be written as a univariate polynomial &lt;span class="math"&gt;\(P\)&lt;/span&gt; in &lt;span class="math"&gt;\(t\)&lt;/span&gt;, with coefficients in &lt;span class="math"&gt;\(R\)&lt;/span&gt;. The
    coefficient &lt;span class="math"&gt;\(c_j(P)\)&lt;/span&gt; of &lt;span class="math"&gt;\(t^j\)&lt;/span&gt; in the polynomial is the following.
    &lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
      c_j(P) = \binom{j-m}{j} \phi\left( A_1, \ldots, A_1, A_{m+1}, \ldots, A_{m+1}, A_2, \ldots, A_m\right) 
    \end{align*}&lt;/div&gt;
&lt;p&gt;
    Here &lt;span class="math"&gt;\(A_1\)&lt;/span&gt; is repeated &lt;span class="math"&gt;\(j-m - j\)&lt;/span&gt; times, and &lt;span class="math"&gt;\(A_{m+1}\)&lt;/span&gt; repeated &lt;span class="math"&gt;\(j\)&lt;/span&gt; times. Similarly, consider
    the polynomial &lt;span class="math"&gt;\(P'\)&lt;/span&gt; one gets by expanding out the conjugated version of expression
    \ref{eq:1}. The coefficient &lt;span class="math"&gt;\(c_j(P')\)&lt;/span&gt; of &lt;span class="math"&gt;\(t^j\)&lt;/span&gt; in &lt;span class="math"&gt;\(P'\)&lt;/span&gt; is given by a similar expression.
    &lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
      c_j(P') = \binom{j-m}{j}
      \phi\left( gA_1g^{-1}, \ldots, gA_1g^{-1}
      , gA_{m+1}g^{-1}, \ldots, gA_{m+1}g^{-1}, gA_2g^{-1}, \ldots, gA_mg^{-1}\right) 
    \end{align*}&lt;/div&gt;
&lt;p&gt;
    Recall again that by the induction hypothesis, the polynomials &lt;span class="math"&gt;\(P\)&lt;/span&gt; and &lt;span class="math"&gt;\(P'\)&lt;/span&gt; are the same. Which
    means their coefficients must also be the same. But the coefficients being equal means that even
    if &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; has &lt;span class="math"&gt;\(m+1\)&lt;/span&gt; different entries, it's still conjugation invariant, hence proving the
    induction step, and the lemma. &lt;span class="math"&gt;\(\blacksquare\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The upshot of proving that every homogeneous polynomial can be polarized is that now we
have an easy way of taking exterior derivative. If &lt;span class="math"&gt;\(f\)&lt;/span&gt; is the degree &lt;span class="math"&gt;\(j\)&lt;/span&gt; homogeneous polynomial, and &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; its
polarization, then the exterior derivative of &lt;span class="math"&gt;\(f(\Omega)\)&lt;/span&gt; is given by the following expression.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
df(\Omega) = j \cdot \phi(d\Omega, \Omega, \Omega, \ldots , \Omega)
\end{align*}&lt;/div&gt;
&lt;p&gt;
Using normal coordinates, and exploiting the multilinearity of &lt;span class="math"&gt;\(\phi\)&lt;/span&gt;, we see that every global
&lt;span class="math"&gt;\(2\)&lt;/span&gt;-form obtained from the curvature form by applying the polynomial &lt;span class="math"&gt;\(f\)&lt;/span&gt; is actually closed,
and hence an element of the cohomology ring. We thus have a way associating a vector bundle
and a connection on it to an element in the cohomology ring. The next step is to show
this assignment is independent of the connection chosen.&lt;/p&gt;
&lt;h3&gt;Independence from choice of connection&lt;/h3&gt;
&lt;p&gt;Given a homogeneous polynomial &lt;span class="math"&gt;\(f\)&lt;/span&gt;, and two connections &lt;span class="math"&gt;\(\nabla_0\)&lt;/span&gt; and &lt;span class="math"&gt;\(\nabla_1\)&lt;/span&gt; on the vector
bundle, we need to show the associated forms &lt;span class="math"&gt;\(f(\Omega_0)\)&lt;/span&gt; and &lt;span class="math"&gt;\(f(\Omega_1)\)&lt;/span&gt; differ by an exact
form. Consider the form &lt;span class="math"&gt;\(\eta_t = f((1-t)\Omega_0 + (t)\Omega_1)\)&lt;/span&gt;. This defines a path in the
space of forms between f(\Omega_0) and &lt;span class="math"&gt;\(f(\Omega_1)\)&lt;/span&gt;. If we show &lt;span class="math"&gt;\(\frac{d}{dt} \eta_t\)&lt;/span&gt; is exact,
that will show what we wanted to prove. In fact, the exterior derivative of the following
form is precisely &lt;span class="math"&gt;\(\frac{d}{dt}\eta_t\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
j \phi \left( A_1 - A_0, \Omega_t, \Omega_t, \ldots, \Omega_t \right)
\end{align*}&lt;/div&gt;
&lt;p&gt;
Here &lt;span class="math"&gt;\(A_i\)&lt;/span&gt; is the connection form of the connection &lt;span class="math"&gt;\(\nabla_i\)&lt;/span&gt;, and &lt;span class="math"&gt;\(\Omega_t\)&lt;/span&gt; the curvature
form of the connection &lt;span class="math"&gt;\(\nabla_t\)&lt;/span&gt;. If one takes the exterior derivative of this expression, using
the normal coordinates, one can see that it's the same as &lt;span class="math"&gt;\(\frac{d}{dt} \eta_t\)&lt;/span&gt;. This proves that 
the choice of connection doesn't matter&lt;sup id="fnref-2"&gt;&lt;a class="footnote-ref" href="#fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;The Chern class&lt;/h2&gt;
&lt;p&gt;Now that we have seen how to construct characteristic classes using the curvature form, we'll
construct a specific example, these are the ones that are called the Chern classes. Let
&lt;span class="math"&gt;\(E\)&lt;/span&gt; be a rank &lt;span class="math"&gt;\(k\)&lt;/span&gt; vector bundle, and let &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; be the curvature of a chosen connection on &lt;span class="math"&gt;\(E\)&lt;/span&gt;.
Consider the following polynomial in &lt;span class="math"&gt;\(t\)&lt;/span&gt;, where &lt;span class="math"&gt;\(t \in \mathbb{R}\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\det(t\Omega + I) = \sum_{i=1}^{k} f_i(\Omega) t^i
\end{align*}&lt;/div&gt;
&lt;p&gt;
Each of the &lt;span class="math"&gt;\(f_i(\Omega)\)&lt;/span&gt; are homogeneous degree &lt;span class="math"&gt;\(i\)&lt;/span&gt; polynomials in &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt;. Because
the left hand side is conjugation invariant, so is each of the &lt;span class="math"&gt;\(f_i(\Omega)\)&lt;/span&gt;. That means
each &lt;span class="math"&gt;\(f_i(\Omega)\)&lt;/span&gt; defines an element (of degree &lt;span class="math"&gt;\(2i\)&lt;/span&gt;) in the cohomology ring of the base space &lt;span class="math"&gt;\(M\)&lt;/span&gt;.
The &lt;span class="math"&gt;\(i\)&lt;/span&gt;&lt;sup&gt;th&lt;/sup&gt; Chern class of the vector bundle &lt;span class="math"&gt;\(E\)&lt;/span&gt; is defined to be &lt;span class="math"&gt;\(f_i(\Omega)\)&lt;/span&gt;. The previous part 
shows that this is well defined independent of the connection chosen.&lt;/p&gt;
&lt;p&gt;The Chern classes satisfy several nice properties, including a product formula
for the Whitney sum of two vector bundles, naturality, etc. The Wikipedia &lt;a href="https://en.wikipedia.org/wiki/Chern_class#Construction_of_Chern_classes"&gt;page&lt;/a&gt;
provides a good description, as well as references for further reading.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-1"&gt;
&lt;p&gt;The reason why this is called the curvature form is that in the case of the Levi-Civita
connection on a Riemannian manifold, this definition reduces to the standard Riemann curvature
endomorphism. &lt;a href="https://en.wikipedia.org/wiki/Curvature_form#Curvature_form_in_a_vector_bundle"&gt;See this&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref-1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-2"&gt;
&lt;p&gt;This proof of independence from the connection was taken from the problem set &lt;a href="http://math.iisc.ac.in/~vamsipingali/HW43392018.pdf"&gt;here&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref-2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="differential-geometry"></category><category term="vector-bundles"></category></entry><entry><title>A week at Berlin Mathematical School</title><link href="/bms-week.html" rel="alternate"></link><published>2018-02-24T00:00:00+05:30</published><updated>2018-02-24T00:00:00+05:30</updated><author><name>Sayantan Khan</name></author><id>tag:None,2018-02-24:/bms-week.html</id><summary type="html">&lt;p&gt;I spent the last week (18th to 24th February) at Berlin, courtesy Berlin Mathematical School,
who invited me over for the BMS Days (where I had an interview for a PhD position), as well
as the BMS Student Conference which immediately followed the BMS Days. I heard a lot of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I spent the last week (18th to 24th February) at Berlin, courtesy Berlin Mathematical School,
who invited me over for the BMS Days (where I had an interview for a PhD position), as well
as the BMS Student Conference which immediately followed the BMS Days. I heard a lot of talks
on very interesting stuff, some of which I want to outline here, just to have an account of it,
if nothing else; this will also serve as a reminder of the areas and results I might want to follow
up on some time in the future.&lt;/p&gt;
&lt;h2&gt;The math talks (in no particular order)&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;I'll only write about some of the talk; although all of them were fairly interesting,
some were more interesting than others. &lt;/p&gt;
&lt;h3&gt;The computational complexity of query answering under updates (Nicole Schweikardt, HU Berlin)&lt;/h3&gt;
&lt;p&gt;This talk outlined the idea of analyzing database systems from the point of view
of computational complexity theory, that is to say, prove effective lower bounds on
the time complexity of querying a database (and to be more specific, time complexity
in terms of only the database size for a fixed query, as well as the in terms of the
complexity of the query and the database size). The query language itself was modelled as
a first order language with a fixed number of atomic predicates depending on the type 
of the database (first order language here means that the atomic predicates maybe negated,
conjuncted, and disjuncted, i.e. NOTed, ANDed, and ORed, and one is also allowed to use
existential and universal qualifiers over elements of the database). This was the general
framework: the results in the presentation however looked at the subclass of queries
(the &lt;em&gt;Conjunctive Queries&lt;/em&gt;) which
only used AND of atomic propositions, and only used the existential qualifiers&lt;sup id="fnref-2"&gt;&lt;a class="footnote-ref" href="#fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;For a fixed query, Nicole described a good algorithm and a data structure for the
database such that existence and enumeration of the entries satisfying the queries could
be done reasonably fast, as well as updating the database. &lt;/p&gt;
&lt;h3&gt;Orbit Closures of Homogeneous Forms (Jesko Hüttenhain, TU Berlin)&lt;/h3&gt;
&lt;p&gt;This talk was motivated by the difference between the complexity class #&lt;strong&gt;P&lt;/strong&gt; and the
class &lt;strong&gt;NP&lt;/strong&gt;, which the speaker roughly described as the difference in difficulty between
computing the permanent and the determinant of a given matrix&lt;sup id="fnref-3"&gt;&lt;a class="footnote-ref" href="#fn-3"&gt;3&lt;/a&gt;&lt;/sup&gt;. It's however only a belief
and not really known whether the former problem is strictly harder than the latter. The speaker
proposed a possible line of attack via algebraic geometry. Consider the determinant function on
&lt;span class="math"&gt;\(M_n(\mathbb{C})\)&lt;/span&gt;. It is a homogeneous polynomial of degree &lt;span class="math"&gt;\(n\)&lt;/span&gt; in &lt;span class="math"&gt;\(n^2\)&lt;/span&gt; complex variables,
and it's therefore a point in the space &lt;span class="math"&gt;\(\mathbb{C}[x_1, \ldots, x_{n^2}]\)&lt;/span&gt;. We can now look
at the action of &lt;span class="math"&gt;\(GL(n, \mathbb{C})\)&lt;/span&gt; on this space defined in the following manner.
&lt;/p&gt;
&lt;div class="math"&gt;$$\sigma_A: \det(X) \mapsto \det(AX)$$&lt;/div&gt;
&lt;p&gt;
The orbit defines a subset of &lt;span class="math"&gt;\(\mathbb{C}[x_1, \ldots, x_{n^2}]\)&lt;/span&gt;, and this subset essentially
corresponds to all the polynomials which are as easy to compute as the determinant. Looking
at the orbit of the permanent polynomial under the same action, we would get the set of polynomials
which are as hard to compute as the permanent is. A way to show the permanent is harder to compute than
the determinant would be to show that the two orbits are different. If one looks at the closure
of the orbits, and shows that they are different, then one would have shown that even approximating
the permanent is hard&lt;sup id="fnref-4"&gt;&lt;a class="footnote-ref" href="#fn-4"&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Jesko then stated one of his results, which characterized the boundary of one such orbit
closure. He also mentioned that this approach to complexity theory might take a while to
bear significant results, as the foundations of this area are being built up.&lt;/p&gt;
&lt;h3&gt;(Some aspects of) Convexity and curvature (Stephen Lynch, FU Berlin)&lt;/h3&gt;
&lt;p&gt;This talk was a presentation of Stephen's recent work (which is also on the 
&lt;a href="https://arxiv.org/abs/1709.09697"&gt;arXiv&lt;/a&gt;). This work generalized convex embeddings
of &lt;span class="math"&gt;\(S^n\)&lt;/span&gt; into &lt;span class="math"&gt;\(\mathbb{R}^{n+1}\)&lt;/span&gt; to higher co-dimension embeddings, where the notion
of convexity does not make sense. This was done by replacing the condition of convexity
by an inequality on the second fundamental form, which is exactly equivalent to convexity
in the case of co-dimension &lt;span class="math"&gt;\(1\)&lt;/span&gt;. This sort of inequality, called the pinching condition,
leads to the solution of the mean curvature flow existing for all time, the solution
exhibited further rigidity in the sense that the evolution of time of the sphere is just
homothety.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-1"&gt;
&lt;p&gt;The complete list of BMS Student Conference talks is
&lt;a href="https://bmsstudconf.github.io/2018/talks.html"&gt;here&lt;/a&gt; and the ones given
at BMS Days are listed &lt;a href="https://www.math-berlin.de/academics/bms-days"&gt;here&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref-1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-2"&gt;
&lt;p&gt;This kind of restriction is quite reminiscent of monotone circuits, and I wondered
whether there was any link between presented results, and lower bounds on monotone
circuits: the speaker however had only chosen this subclass as a simpler problem to tackle
before tackling the problem over the full first order logic. But maybe the results obtained
for the full first order logic might not be as good as the ones of only conjunctive queries.
Perhaps I should have a look at this problem again in the future: some sort of such obstruction
might turn up, and if I were to be even more optimistic, perhaps a direct correspondence between
monotone circuits and conjunctive queries, and general circuits and general queries.&amp;#160;&lt;a class="footnote-backref" href="#fnref-2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-3"&gt;
&lt;p&gt;The former problem is quite hard, as even computing the permanent of a 0-1 matrix is #&lt;strong&gt;P&lt;/strong&gt;-complete,
and the latter problem is fairly easy, being in the class &lt;strong&gt;P&lt;/strong&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref-3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-4"&gt;
&lt;p&gt;This sort of approach is a part of the nascent area of &lt;a href="https://en.wikipedia.org/wiki/Geometric_complexity_theory"&gt;geometric complexity theory&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref-4" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="travel"></category><category term="math-talks"></category></entry><entry><title>Setting up GitLab to automatically generate PDFs from committed LaTeX files</title><link href="/latex-gitlab-ci.html" rel="alternate"></link><published>2018-01-17T00:00:00+05:30</published><updated>2018-01-17T00:00:00+05:30</updated><author><name>Sayantan Khan</name></author><id>tag:None,2018-01-17:/latex-gitlab-ci.html</id><summary type="html">&lt;p&gt;I had been meaning to get started with GitLab's continuous integration
to generate PDFs of my assignments and notes, rather then generating the
PDFs offline and committing them to the repository as well, but I always
kept delaying the migration because of the lack of sufficient documentation
on the matter …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I had been meaning to get started with GitLab's continuous integration
to generate PDFs of my assignments and notes, rather then generating the
PDFs offline and committing them to the repository as well, but I always
kept delaying the migration because of the lack of sufficient documentation
on the matter. This morning I finally got around to doing it, and I thought
I'll document it for anyone who wishes to do the same in the future.&lt;/p&gt;
&lt;h2&gt;Outline of GitLab's continuous integration service&lt;/h2&gt;
&lt;p&gt;On receiving a commit to a repository hosted on GitLab, it
checks whether the repository has a file named &lt;code&gt;.gitlab-ci.yml&lt;/code&gt;
in the root directory. This file contains the commands to be executed
by whatever computer is running the continuous integration service.
In GitLab's parlance, these are called &lt;a href="https://docs.gitlab.com/runner/"&gt;Runners&lt;/a&gt;.
These runners can be any computer, from a server running in your room, to a short lived
VM on the cloud. For the free tier, GitLab provides access to runners on 
&lt;a href="https://aws.amazon.com/"&gt;AWS&lt;/a&gt;, but with the restriction of having only 2000
minutes of compute time per month.&lt;/p&gt;
&lt;p&gt;For these free runners, there's no configuration to be done from our side; all we need
to do is push a &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; to our repository, and GitLab takes care of
running it on a runner. There is one thing to watch out for though. The free runners
are usually short lived, and one can't install software on them, which means
we can't do a &lt;code&gt;sudo apt install texlive-full&lt;/code&gt; as a command that runs on the runner.
Luckily, the runners do have 
&lt;a href="https://www.docker.com/"&gt;docker&lt;/a&gt;[&lt;a href="http://www.zdnet.com/article/what-is-docker-and-why-is-it-so-darn-popular/"&gt;2&lt;/a&gt;]
installed on them, which means we can use some image from which has all the
necessary software (i.e. &lt;code&gt;texlive-full&lt;/code&gt;) installed on it already.&lt;/p&gt;
&lt;h2&gt;Configuring the runner to compile LaTeX&lt;/h2&gt;
&lt;p&gt;A cursory google search for a suitable configuration turned up the following
&lt;a href="https://github.com/aufenthaltsraum/stuff/wiki/Using-GitLab-CI-for-Building-LaTeX"&gt;configuration&lt;/a&gt;,
which is rather rudimentary, but is good guide for creating
our configuration.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;compile_pdf&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;aergus&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;latex&lt;/span&gt;
  &lt;span class="n"&gt;script&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;latexmk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="n"&gt;my_file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tex&lt;/span&gt;
  &lt;span class="n"&gt;artifacts&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;paths&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;my_file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pdf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's go over this line by line. The first line describes the name of the job that
will be run. There can be several jobs described in a configuration file, and they
will usually be run asynchronously unless some job is listed as a dependency of another.
The next line describes what docker image to fetch: &lt;code&gt;aergus/latex&lt;/code&gt; is Debian Testing
with &lt;code&gt;texlive-full&lt;/code&gt; already installed. The next two lines describe the script that
will be run: these scripts are run from the root directory of the repository. In
this case, that means &lt;code&gt;latexmk -pdf&lt;/code&gt; is being run on &lt;code&gt;my_file.tex&lt;/code&gt; which is
at the root directory of the repository. It's possible to upload a shell script
or a Makefile to the repository and run that instead (I ended up doing the latter).
However, the files generated during the build process are discarded, which is not
quite what I wanted. I would like to keep the generated PDFs; the artifacts line
does exactly that. The artifacts can later be browsed or downloaded via the GitLab
web interface.&lt;/p&gt;
&lt;p&gt;In my case however, the setup is a bit more complex. I do not keep all my TeX files
in the root directory, but rather organize them by course and assignment number.
So the TeX file for the fourth assignment for a topology course will have the following
location: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Math/MA232\ Topology/assignments/04/assignment_04.tex
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What I would like is to make sure the generated PDF for this TeX file is
placed in the following location.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Math/MA232\ Topology/assignments/assignment_04.pdf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I'd also like my thesis to be compiled on each commit; the location
of my thesis in the repository is the following.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Math/UM400\ Undergraduate\ Project/thesis/thesis.tex
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I wrote up a &lt;code&gt;Makefile&lt;/code&gt; that does all the compilation work, and places the PDFs
in appropriate locations.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="sr"&gt;/MA339\ Geometric\ Analysis/&lt;/span&gt;&lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
    &lt;span class="n"&gt;latexmk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;&lt;span class="n"&gt;assignment_&lt;/span&gt;&lt;span class="o"&gt;*.&lt;/span&gt;&lt;span class="n"&gt;tex&lt;/span&gt; 

&lt;span class="n"&gt;thesis&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="sr"&gt;/UM400\ Undergraduate\ Project/&lt;/span&gt;&lt;span class="n"&gt;thesis&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
    &lt;span class="n"&gt;latexmk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="n"&gt;thesis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tex&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And the &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; file I finally ended up using was this.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;stages:
  - build
compile_pdf:
  image: aergus/latex
  script:
    - make assignments
    - make thesis
  stage: build
  artifacts:
    paths:
      - &amp;quot;Math/MA339 Geometric Analysis/assignments/assignment_*.pdf&amp;quot;
      - &amp;quot;Math/UM400 Undergraduate Project/thesis/thesis.pdf&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Adding these two files to the root directory of the repository does the trick.
One issue I came up against was the spaces in filenames shouldn't be escaped
with a backslash, but rather the whole file name should be enclosed in quotes.&lt;/p&gt;
&lt;p&gt;The generated artifacts can be browsed by visiting the following link.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;https://gitlab.com/&amp;lt;username&amp;gt;/&amp;lt;repo-name&amp;gt;/-/jobs/artifacts/master/browse?job=compile_pdf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It seems that compiling all the files after a commit takes up four to five minutes on 
the runner, the majority of the time being spent fetching the docker container.
That translates to roughly 400 compiles in a month, which is a reasonable enough
limit, if one or two people are committing files to the repository, but might
be a problem if a large group of people are committing a large number of files
to the repository.&lt;/p&gt;
&lt;p&gt;The point of this whole exercise was to let me get rid of a LaTeX installation
on the devices I carry to class to make notes, which is an extremely
space constrained Nexus 7 tablet. All I now have installed on the tablet is git and
Emacs, after uninstalling texlive (also, compiling PDFs locally on the tablet would
take upwards of a minute on the under powered CPU it had).&lt;/p&gt;</content><category term="gitlab"></category><category term="LaTeX"></category></entry><entry><title>Cohomology as a measure of local to global failure</title><link href="/cohomology-local-global.html" rel="alternate"></link><published>2017-12-25T00:00:00+05:30</published><updated>2017-12-25T00:00:00+05:30</updated><author><name>Sayantan Khan</name></author><id>tag:None,2017-12-25:/cohomology-local-global.html</id><summary type="html">&lt;h2&gt;Motivation for cohomology&lt;/h2&gt;
&lt;p&gt;In most introductory algebraic topology courses, cohomology is rather poorly motivated. It's most
commonly seen form in an algebraic topology course is singular cohomology, which arises as a the
homology of the dual of the singular chain complex, but that doesn't really tell you why it's of …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Motivation for cohomology&lt;/h2&gt;
&lt;p&gt;In most introductory algebraic topology courses, cohomology is rather poorly motivated. It's most
commonly seen form in an algebraic topology course is singular cohomology, which arises as a the
homology of the dual of the singular chain complex, but that doesn't really tell you why it's of any
more interest than singular homology, aside from the fact that you get an additional cup product
which you did not have before. However, this approach obscures the geometric meaning of cohomology.&lt;/p&gt;
&lt;p&gt;A much more intuitive introduction to cohomology turns out to be De Rham cohomology, often
encountered in introductory differential geometry courses. Loosely speaking, De Rham cohomology
measures in how many different ways can a closed form fail to be exact.&lt;/p&gt;
&lt;p&gt;Another cohomology theory we'll look at is sheaf cohomology. Loosely, the cohomology of a sheaf
measures how a certain functor &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt;, which we'll define later fails to be an exact functor.&lt;/p&gt;
&lt;p&gt;In the case of De Rham cohomology, we'll interpret the form being closed as a local property, and it
being exact a global property, and the the case of sheaf cohomology, the exactness of the following
sequence (the exact details of which we'll see in a later section) as a local property.  &lt;/p&gt;
&lt;div class="math"&gt;$$0
\rightarrow \mathcal{S}_1 \rightarrow \mathcal{S}_2\rightarrow \mathcal{S}_3 \rightarrow 0$$&lt;/div&gt;
&lt;p&gt; The
exactness of the sequence we get by applying &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; to the above sequence turns out to be a global
property.&lt;/p&gt;
&lt;p&gt;In both the cases, the cohomology measures how the local property fails to translate to the global
one.&lt;/p&gt;
&lt;h2&gt;De Rham Cohomology&lt;/h2&gt;
&lt;p&gt;The De Rham cohomology of a manifold &lt;span class="math"&gt;\(M\)&lt;/span&gt; (of dimension &lt;span class="math"&gt;\(m\)&lt;/span&gt;) is the homology of the following of the
following cochain sequence.  &lt;/p&gt;
&lt;div class="math"&gt;$$0 \xrightarrow{d} \Lambda^0(M) \xrightarrow{d} \Lambda^1(M)
\xrightarrow{d} \cdots \xrightarrow{d} \Lambda^m(M) \xrightarrow{d} 0$$&lt;/div&gt;
&lt;p&gt; Here, &lt;span class="math"&gt;\(\Lambda^k(M)\)&lt;/span&gt; is the
space of &lt;span class="math"&gt;\(k\)&lt;/span&gt;-forms on &lt;span class="math"&gt;\(M\)&lt;/span&gt;, and &lt;span class="math"&gt;\(d\)&lt;/span&gt; is the exterior derivative operator.  For a &lt;span class="math"&gt;\(k\)&lt;/span&gt;-form &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; to
be closed, &lt;span class="math"&gt;\(d\omega\)&lt;/span&gt; must be &lt;span class="math"&gt;\(0\)&lt;/span&gt;. This is a local property, in the sense that &lt;span class="math"&gt;\(d\omega\)&lt;/span&gt; evaluated at
any point &lt;span class="math"&gt;\(p \in M\)&lt;/span&gt; depends only on the value of &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; on any small neighbourhood of &lt;span class="math"&gt;\(p\)&lt;/span&gt;.  In
fact, one can say a little more, and claim that &lt;span class="math"&gt;\(d\omega(p)\)&lt;/span&gt; depends only on the &lt;em&gt;germ&lt;/em&gt; of &lt;span class="math"&gt;\(\omega\)&lt;/span&gt;
at &lt;span class="math"&gt;\(p\)&lt;/span&gt;.  If we pick a Euclidean neighbourhood &lt;span class="math"&gt;\(U\)&lt;/span&gt; of &lt;span class="math"&gt;\(p\)&lt;/span&gt; which is homeomorphic to the open unit
ball, the Poincaré lemma tells us that there is some &lt;span class="math"&gt;\((k+1)\)&lt;/span&gt;-form &lt;span class="math"&gt;\(\eta\)&lt;/span&gt; defined on &lt;span class="math"&gt;\(U\)&lt;/span&gt; such that
&lt;span class="math"&gt;\(\omega = d\eta\)&lt;/span&gt;. In other words, the closed form &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; is locally exact.&lt;/p&gt;
&lt;p&gt;The De Rham cohomology class of &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; measures how badly does the property of local exactness
fail to translate to global exactness. We can write &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; as &lt;span class="math"&gt;\(\gamma + d\zeta\)&lt;/span&gt;, where &lt;span class="math"&gt;\(\gamma\)&lt;/span&gt; is
the canonical representative of the cohomology class of &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; (more on this in later posts), and
&lt;span class="math"&gt;\(\zeta\)&lt;/span&gt; is a &lt;span class="math"&gt;\((k-1)\)&lt;/span&gt;-form. If we stretch the analogy a bit, we can say &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; misses being
globally exact by &lt;span class="math"&gt;\(\gamma\)&lt;/span&gt; amount. This is the first example of how cohomology measures how badly a
local property fails to be global.&lt;/p&gt;
&lt;h2&gt;Sheaf Cohomology&lt;/h2&gt;
&lt;p&gt;Before we see what sort of local to global failure sheaf cohomology measures, we'll quickly define
sheaves and sheaf cohomology, and look at one example.&lt;/p&gt;
&lt;h3&gt;Quick introduction to sheaves&lt;/h3&gt;
&lt;p&gt;Given a manifold &lt;span class="math"&gt;\(M\)&lt;/span&gt; (whatever we discuss will hold in for Hausdorff spaces, and with a little more
work, can be made to work even for a larger class of spaces like spectra of rings), a sheaf
&lt;span class="math"&gt;\(\mathcal{S}\)&lt;/span&gt; of &lt;span class="math"&gt;\(K\)&lt;/span&gt;-modules (&lt;span class="math"&gt;\(K\)&lt;/span&gt; is always assumed to be a commutative ring with identity) over &lt;span class="math"&gt;\(M\)&lt;/span&gt;
is a topological space &lt;span class="math"&gt;\(\mathcal{S}\)&lt;/span&gt; with a surjective map &lt;span class="math"&gt;\(\pi: \mathcal{S} \to M\)&lt;/span&gt;, such that the
following properties are satisfied.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\pi\)&lt;/span&gt; is a local homeomorphism, i.e. for any point &lt;span class="math"&gt;\(s \in \mathcal{S}\)&lt;/span&gt;, there's a neighbourhood
of &lt;span class="math"&gt;\(s\)&lt;/span&gt; such that &lt;span class="math"&gt;\(\pi\)&lt;/span&gt; restricted to that neighbourhood is a homeomorphism.&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\pi^{-1}(x)\)&lt;/span&gt;, which we'll denote by &lt;span class="math"&gt;\(\mathcal{O}_x\)&lt;/span&gt;, is a &lt;span class="math"&gt;\(K\)&lt;/span&gt;-module, for all &lt;span class="math"&gt;\(x \in
M\)&lt;/span&gt;. &lt;span class="math"&gt;\(\mathcal{O}_x\)&lt;/span&gt; is called the stalk of &lt;span class="math"&gt;\(\mathcal{S}\)&lt;/span&gt; at &lt;span class="math"&gt;\(x\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The module operations on the stalk are continuous, i.e. if we look at the stalk with the subspace
topology, the module operations of addition and scalar multiplication are continuous.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Sheaves in some sense a modules parametrized by the space &lt;span class="math"&gt;\(M\)&lt;/span&gt;, like vector bundles, but vector
bundles do not satisfy the first condition, unlike sheaves.  The simplest example of a sheaf is the
&lt;em&gt;constant sheaf&lt;/em&gt; which is just &lt;span class="math"&gt;\(M \times V\)&lt;/span&gt;, where &lt;span class="math"&gt;\(V\)&lt;/span&gt; is a &lt;span class="math"&gt;\(K\)&lt;/span&gt;-module with the discrete topology.&lt;/p&gt;
&lt;p&gt;Another important example is the sheaf of germs of &lt;span class="math"&gt;\(C^{\infty}\)&lt;/span&gt; functions on a manifold &lt;span class="math"&gt;\(M\)&lt;/span&gt;. For
each &lt;span class="math"&gt;\(x \in M\)&lt;/span&gt;, a point in &lt;span class="math"&gt;\(\mathcal{O}_x\)&lt;/span&gt; is an equivalence class of functions, the equivalence
relation being that &lt;span class="math"&gt;\(f \sim g\)&lt;/span&gt; if &lt;span class="math"&gt;\(f\)&lt;/span&gt; and &lt;span class="math"&gt;\(g\)&lt;/span&gt; agree on some neighbourhood of &lt;span class="math"&gt;\(x\)&lt;/span&gt;. This sheaf
deserves a post of its own, and I shall write about it in the future.&lt;/p&gt;
&lt;p&gt;The last example, which will be key to our goal, is the &lt;em&gt;skyscraper sheaf&lt;/em&gt;. We'll describe it by
first describing the stalk at each point, and then putting an appropriate topology on it. Fix a
point &lt;span class="math"&gt;\(x_0 \in M\)&lt;/span&gt;.  The stalk &lt;span class="math"&gt;\(\mathcal{O}_{x_0}\)&lt;/span&gt; at &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; will be &lt;span class="math"&gt;\(K\)&lt;/span&gt; as a module over itself. The
stalk at every other point is the zero module. As a set, our sheaf is the following.  &lt;/p&gt;
&lt;div class="math"&gt;$$\mathcal{S}
= K \sqcup \bigsqcup_{x \neq x_0} \{0\}$$&lt;/div&gt;
&lt;p&gt; The question is what topology do we put on this space. The
&lt;a href="https://en.wikipedia.org/wiki/Non-Hausdorff_manifold#Line_with_two_origins"&gt;line with two origins&lt;/a&gt;
provides a hint. What we do is take &lt;span class="math"&gt;\(|K|\)&lt;/span&gt; copies of the space &lt;span class="math"&gt;\(M\)&lt;/span&gt;, and if &lt;span class="math"&gt;\(x \neq x_0\)&lt;/span&gt;, we identify
all of those &lt;span class="math"&gt;\(x\)&lt;/span&gt;'s, otherwise we do nothing. It's not too hard to check that this defines a sheaf
over &lt;span class="math"&gt;\(M\)&lt;/span&gt; (the local homeomorphism property is the hardest to check, and relies on the fact that
points are closed in Hausdorff spaces). In fact, if &lt;span class="math"&gt;\(M = \mathbb{R}\)&lt;/span&gt; and &lt;span class="math"&gt;\(K = \mathbb{Z}/2\)&lt;/span&gt;, then
then skyscraper sheaf at &lt;span class="math"&gt;\(0\)&lt;/span&gt; &lt;em&gt;is&lt;/em&gt; the line with two origins. The reason this is called the
skyscraper sheaf is because only the stalk at &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; is tall, the stalks everywhere are flat, which
makes it look like a tall structure in an otherwise flat featureless landscape.&lt;/p&gt;
&lt;p&gt;We're really interested in is a variant of a skyscraper sheaf with two skyscrapers, i.e. the stalks
at points &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; and &lt;span class="math"&gt;\(x_1\)&lt;/span&gt; are &lt;span class="math"&gt;\(K\)&lt;/span&gt;, and otherwise &lt;span class="math"&gt;\(0\)&lt;/span&gt;. The topology on this sheaf can be defined
analogously. We'll come back to this example once we've defined sheaf cohomology.&lt;/p&gt;
&lt;h3&gt;The category of sheaves of &lt;span class="math"&gt;\(K\)&lt;/span&gt;-modules over a space&lt;/h3&gt;
&lt;p&gt;Just like in the case of a vector bundles over a manifold &lt;span class="math"&gt;\(M\)&lt;/span&gt;, where the &lt;em&gt;right&lt;/em&gt; kind of map between
vector bundles is a smooth map that is a linear map on each fibre, the &lt;em&gt;right&lt;/em&gt; kind of map between
two sheaves &lt;span class="math"&gt;\(\mathcal{S}_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(\mathcal{S}_2\)&lt;/span&gt; on a space &lt;span class="math"&gt;\(M\)&lt;/span&gt; is a continuous map &lt;span class="math"&gt;\(f\)&lt;/span&gt; such that it
satisfies the following properties.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\pi = \pi \circ f\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f\)&lt;/span&gt; restricted to any any stalk &lt;span class="math"&gt;\(\mathcal{O}_x\)&lt;/span&gt; is a &lt;span class="math"&gt;\(K\)&lt;/span&gt;-module homomorphism.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Fixing a space &lt;span class="math"&gt;\(M\)&lt;/span&gt;, we get the category of sheaves of &lt;span class="math"&gt;\(K\)&lt;/span&gt;-modules over &lt;span class="math"&gt;\(M\)&lt;/span&gt;, whose objects are
sheaves, and the morphisms are what we just defined, called sheaf homomorphisms. It follows from the
fact that &lt;span class="math"&gt;\(\pi\)&lt;/span&gt; is a local homeomorphism that even sheaf homomorphisms are local homeomorphisms.
This category turns out to be especially nice, sharing many characteristics with the category of
abelian groups and more generally, the category of &lt;span class="math"&gt;\(K\)&lt;/span&gt;-modules, such as maps possessing kernels and
cokernels, and possessing a version of the &lt;a href="https://en.wikipedia.org/wiki/Isomorphism_theorems#First_isomorphism_theorem"&gt;First Isomorphism
Theorem&lt;/a&gt;.  This sort
of category is called an abelian category, and this category is the appropriate category to do
homological algebra in. Coming back to sheaves, the kernel of a sheaf homomorphism &lt;span class="math"&gt;\(f: \mathcal{S}_1
\to \mathcal{S}_2\)&lt;/span&gt; is the set of all points which map to the zero element in the stalk. With a
little bit of work, we can show the image of &lt;span class="math"&gt;\(f\)&lt;/span&gt; is a sheaf in its own right, and subsheaf of
&lt;span class="math"&gt;\(\mathcal{S}_2\)&lt;/span&gt;, just like the kernel of &lt;span class="math"&gt;\(f\)&lt;/span&gt; is a subsheaf of &lt;span class="math"&gt;\(\mathcal{S}_1\)&lt;/span&gt; (the definition of a
subsheaf is the most obvious one).&lt;/p&gt;
&lt;p&gt;With all these definitions in hand, we can talk about exact sequences of sheaves. Consider a
sequence of sheaves and sheaf homomorphisms of the following kind.  &lt;/p&gt;
&lt;div class="math"&gt;$$\cdots \xrightarrow{d_{i-2}}
\mathcal{S}_{i-1} \xrightarrow{d_{i-1}} \mathcal{S}_{i} \xrightarrow{d_{i}} \mathcal{S}_{i+1}
\xrightarrow{d_{i+1}} \cdots$$&lt;/div&gt;
&lt;p&gt; This sequence is exact if &lt;span class="math"&gt;\(\mathrm{ker}(d_{i}) =
\mathrm{im}(d_{i-1})\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The next thing we look at is the functor &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; from the category of sheaves of &lt;span class="math"&gt;\(K\)&lt;/span&gt;-modules over
&lt;span class="math"&gt;\(M\)&lt;/span&gt; to the category of &lt;span class="math"&gt;\(K\)&lt;/span&gt;-modules. For each sheaf &lt;span class="math"&gt;\(\mathcal{S}\)&lt;/span&gt;, the object &lt;span class="math"&gt;\(\Gamma(\mathcal{S})\)&lt;/span&gt;
is the module of sections of &lt;span class="math"&gt;\(\mathcal{S}\)&lt;/span&gt;. A section of a sheaf &lt;span class="math"&gt;\(\mathcal{S}\)&lt;/span&gt; is a map &lt;span class="math"&gt;\(s: M \to
\mathcal{S}\)&lt;/span&gt; such that &lt;span class="math"&gt;\(\pi \circ s = \mathrm{id}\)&lt;/span&gt;. Clearly, we can add two sections, and we can
also multiply them by a scalar; we therefore have a &lt;span class="math"&gt;\(K\)&lt;/span&gt;-module. The functor &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; acts on
morphisms by composing them with the section map, i.e. &lt;span class="math"&gt;\(\Gamma(f) = f \circ s\)&lt;/span&gt;. The important
question to ask here is whether the functor &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; is exact, i.e. does it short exact sequences to
short exact sequences. The answer is no. Consider the following short exact sequence.  &lt;/p&gt;
&lt;div class="math"&gt;$$0
\rightarrow \mathcal{S}_1 \xrightarrow{\alpha} \mathcal{S}_2\xrightarrow{\beta} \mathcal{S}_3
\rightarrow 0 \tag{1}$$&lt;/div&gt;
&lt;p&gt; If we apply the functor &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; to the sequence, we get something that is
not completely exact.  &lt;/p&gt;
&lt;div class="math"&gt;$$0 \rightarrow \Gamma(\mathcal{S}_1) \xrightarrow{\Gamma(\alpha)}
\Gamma(\mathcal{S}_2) \xrightarrow{\Gamma(\beta)} \Gamma(\mathcal{S}_3) \rightarrow 0 \tag{2}$$&lt;/div&gt;
&lt;p&gt; This
sequence is exact only exact at &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_1)\)&lt;/span&gt; and &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Suppose some &lt;span class="math"&gt;\(s \in \Gamma(\mathcal{S}_1)\)&lt;/span&gt; maps to &lt;span class="math"&gt;\(0\)&lt;/span&gt; in &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_2)\)&lt;/span&gt;. That tells us
that &lt;span class="math"&gt;\(\Gamma(\alpha)(s) = 0\)&lt;/span&gt;. But that by definition means that &lt;span class="math"&gt;\(\alpha \circ s = 0\)&lt;/span&gt;. But &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;
is injective, which means &lt;span class="math"&gt;\(s = 0\)&lt;/span&gt;. This shows exactness at &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Showing exactness at &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_2)\)&lt;/span&gt; is a little more involved. Consider an element &lt;span class="math"&gt;\(s \in
\Gamma(\mathcal{S}_2)\)&lt;/span&gt; which gets mapped to the zero section in &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_3)\)&lt;/span&gt;. That means
for all &lt;span class="math"&gt;\(m \in M\)&lt;/span&gt;, &lt;span class="math"&gt;\(\beta(s(m)) = 0\)&lt;/span&gt;.  By exactness at &lt;span class="math"&gt;\(\mathcal{S}_2\)&lt;/span&gt;, we can find for each &lt;span class="math"&gt;\(m\)&lt;/span&gt;, an
element &lt;span class="math"&gt;\(s'(m)\)&lt;/span&gt; of &lt;span class="math"&gt;\(\mathcal{S}_1\)&lt;/span&gt; such that &lt;span class="math"&gt;\(\alpha(s'(m)) = s(m)\)&lt;/span&gt;.  Furthermore, because the
original short exact sequence is exact at &lt;span class="math"&gt;\(\mathcal{S}_1\)&lt;/span&gt;, the element &lt;span class="math"&gt;\(s'(m)\)&lt;/span&gt; is uniquely defined
(this is where the argument fails to work for &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_3)\)&lt;/span&gt;). All we need to show now is
that the map &lt;span class="math"&gt;\(m \mapsto s'(m)\)&lt;/span&gt; is a continuous map. This is where we use the fact that sheaf
homomorphisms are local homeomorphisms. For any &lt;span class="math"&gt;\(m\)&lt;/span&gt;, pick a small enough neighbourhood &lt;span class="math"&gt;\(U\)&lt;/span&gt; around
&lt;span class="math"&gt;\(s'(m)\)&lt;/span&gt; such that &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; is a local homeomorphism on &lt;span class="math"&gt;\(U\)&lt;/span&gt;. Then &lt;span class="math"&gt;\(s'^{-1}(U)\)&lt;/span&gt; is given by
&lt;span class="math"&gt;\(s^{-1}(\alpha(U))\)&lt;/span&gt;, which is open since &lt;span class="math"&gt;\(s\)&lt;/span&gt; is a continuous section.&lt;/p&gt;
&lt;p&gt;Notice that the exactness of sequence &lt;span class="math"&gt;\((1)\)&lt;/span&gt; is a purely local property; it suffices to check whether
the sequence on each stalk is exact. On the other hand, showing exactness at &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_3)\)&lt;/span&gt;
would be a global property. This is because given any section &lt;span class="math"&gt;\(s \in \Gamma(\mathcal{S}_3)\)&lt;/span&gt;, the
best we can do is construct sections &lt;span class="math"&gt;\(s_U\)&lt;/span&gt; on open subsets &lt;span class="math"&gt;\(U\)&lt;/span&gt; of &lt;span class="math"&gt;\(M\)&lt;/span&gt;. It might so happen that these
sections defined on different subsets of &lt;span class="math"&gt;\(M\)&lt;/span&gt; cannot be patched together consistently to get a
continuous section. The cohomology of the sheaf will measure how badly the functor &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; fails to
be exact; to be more precise, the cohomology will tell us how extend sequence &lt;span class="math"&gt;\((2)\)&lt;/span&gt; to get an exact
sequence. We'll leave the precise details of this for a later post, and satisfy ourselves with an
example of when exactness fails to happen at &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_3)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To show this, we will exhibit a surjective sheaf homomorphism &lt;span class="math"&gt;\(f\)&lt;/span&gt; such that &lt;span class="math"&gt;\(\Gamma(f)\)&lt;/span&gt; is not a
surjective module map. Consider a connected space &lt;span class="math"&gt;\(M\)&lt;/span&gt;, and let &lt;span class="math"&gt;\(\mathcal{S}_1\)&lt;/span&gt; be the constant sheaf
on &lt;span class="math"&gt;\(M\)&lt;/span&gt;. Recall that this means &lt;span class="math"&gt;\(\mathcal{S}_1\)&lt;/span&gt; is &lt;span class="math"&gt;\(M \times K\)&lt;/span&gt;, with the discrete topology on
&lt;span class="math"&gt;\(K\)&lt;/span&gt;. Let &lt;span class="math"&gt;\(\mathcal{S}_2\)&lt;/span&gt; be the skyscraper sheaf on &lt;span class="math"&gt;\(M\)&lt;/span&gt; with two skyscrapers, which means the stalk
is &lt;span class="math"&gt;\(K\)&lt;/span&gt; at points &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; and &lt;span class="math"&gt;\(x_1\)&lt;/span&gt; and zero otherwise.  On the stalk at point which is not &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; or
&lt;span class="math"&gt;\(x_1\)&lt;/span&gt;, the homomorphism is obviously the zero homomorphism. On the stalk at &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; and &lt;span class="math"&gt;\(x_1\)&lt;/span&gt;, we let
the homomorphism be the identity homomorphism. It's clear that this sheaf homomorphism, call it &lt;span class="math"&gt;\(f\)&lt;/span&gt;
is surjective. But observe that &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_1) = K\)&lt;/span&gt;. That's because we picked &lt;span class="math"&gt;\(M\)&lt;/span&gt; to be a
connected manifold, which means the section must the constant section. On the other hand,
&lt;span class="math"&gt;\(\Gamma(\mathcal{S}_2) = K \oplus K\)&lt;/span&gt;, since the section can take any value independently at &lt;span class="math"&gt;\(x_0\)&lt;/span&gt;
and &lt;span class="math"&gt;\(x_1\)&lt;/span&gt;. Which means &lt;span class="math"&gt;\(\Gamma(f)\)&lt;/span&gt; is a map from &lt;span class="math"&gt;\(K\)&lt;/span&gt; to &lt;span class="math"&gt;\(K \oplus K\)&lt;/span&gt;, which cannot be surjective in
general.&lt;/p&gt;
&lt;p&gt;This tells us that exactness at &lt;span class="math"&gt;\(\Gamma(\mathcal{S}_3)\)&lt;/span&gt; is a global property, and the cohomology
measures (in a loose sense) how the local property of exactness of &lt;span class="math"&gt;\((1)\)&lt;/span&gt; fails to translate to
exactness of &lt;span class="math"&gt;\((2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;ADDENDUM: I will add links to similar expositions whenever I find them.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Čech cohomology and the Mittag-Leffler problem: The Čech cohomology determines
whether meromorphic functions defined on small open sets can be patched together to
get a globally defined meromorphic function satisfying certain properties. 
(&lt;a href="https://toperkin.mysite.syr.edu/talks/sheaves_and_more_cohomology.pdf"&gt;Link&lt;/a&gt; to article)&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="cohomology"></category><category term="sheaves"></category><category term="topology"></category></entry></feed>